using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using TelegramChatViewer.Models;
using TelegramChatViewer.Services;

namespace TelegramChatViewer
{
    public partial class MainWindow : Window
    {
        private readonly Logger _logger;
        private readonly MessageParser _messageParser;
        private VirtualScrollManager _virtualScrollManager;
        
        // Application state
        private List<TelegramMessage> _allMessages = new List<TelegramMessage>();
        private List<TelegramMessage> _currentMessages = new List<TelegramMessage>();
        private string _chatName = "";
        private string _jsonFileDirectory = "";
        
        // Performance settings
        private const int ChunkSize = 500;
        private const int MessagesPerLoad = 500;
        private bool _useVirtualScrolling = true;
        
        // Infinite scroll state
        private bool _infiniteScrollEnabled = false;
        private int _currentChunkIndex = 0;
        private bool _isLoadingMore = false;
        private bool _isInitialSetup = false; // Flag to prevent infinite scroll during initial setup
        
        // Enhanced infinite scroll state management
        private DispatcherTimer _scrollThrottleTimer;
        private double _lastScrollPosition = 0;
        private double _scrollThreshold = 0.85; // Trigger at 85%
        private DateTime _lastScrollTrigger = DateTime.MinValue;
        private const int ScrollCooldownMs = 500; // Reduced from 1000ms
        private const int ScrollThrottleMs = 50; // Reduced from 100ms for better responsiveness
        
        // Progressive loading state
        private double _previousScrollPosition = 0;
        private bool _isScrollingDown = true;
        private double _loadingZoneStart = 0.80; // Start considering loading at 80%
        private double _loadingZoneEnd = 0.95;   // Stop loading at 95%
        private int _progressiveLoadSize = 500;  // Increased from 100 for better performance
        
        // Performance optimization caches
        private readonly Dictionary<string, Brush> _resourceCache = new Dictionary<string, Brush>();
        private readonly Queue<FrameworkElement> _elementPool = new Queue<FrameworkElement>();
        private const int MaxPoolSize = 50;
        
        // Search state
        private List<TelegramMessage> _searchResults = new List<TelegramMessage>();
        private int _currentSearchIndex = 0;
        private DispatcherTimer _searchTimer;
        private string _currentSearchTerm = ""; // Track current search term for highlighting
        
        // Member colors for consistent user identification
        private readonly Dictionary<string, Brush> _memberColors = new Dictionary<string, Brush>();
        // Username colors with excellent contrast for both light and dark themes
        private readonly Brush[] _lightColorPalette = {
            new SolidColorBrush(Color.FromRgb(0xB8, 0x1C, 0x1C)), // Dark Red - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x1B, 0x5E, 0x20)), // Dark Green - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x1A, 0x23, 0x7E)), // Dark Blue - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x8A, 0x4F, 0x00)), // Dark Orange - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x6A, 0x1B, 0x9A)), // Dark Purple - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x00, 0x5A, 0x5A)), // Dark Teal - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0xA0, 0x27, 0x00)), // Dark Red-Orange - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x33, 0x69, 0x1E)), // Dark Olive - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x8E, 0x24, 0x4D)), // Dark Magenta - Strong contrast on light
            new SolidColorBrush(Color.FromRgb(0x1B, 0x32, 0x65))  // Dark Navy - Strong contrast on light
        };

        private readonly Brush[] _darkColorPalette = {
            new SolidColorBrush(Color.FromRgb(0xFF, 0x8A, 0x8A)), // Bright Red - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0x8A, 0xFF, 0x8A)), // Bright Green - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0x8A, 0x8A, 0xFF)), // Bright Blue - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0xFF, 0xCC, 0x80)), // Bright Orange - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0xFF, 0x8A, 0xFF)), // Bright Purple - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0x8A, 0xFF, 0xFF)), // Bright Teal - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0xFF, 0xB3, 0x80)), // Bright Orange-Red - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0xB3, 0xFF, 0x80)), // Bright Lime - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0xFF, 0x80, 0xB3)), // Bright Pink - Strong contrast on dark
            new SolidColorBrush(Color.FromRgb(0x80, 0xB3, 0xFF))  // Bright Sky Blue - Strong contrast on dark
        };

        private Brush[] _colorPalette => _isLightMode ? _lightColorPalette : _darkColorPalette;

        // Layout options
        private bool _useAlternatingLayout = true;
        private bool _useAlternatingBackgrounds = true;
        private bool _isLightMode = true;
        private bool _useMassiveLoad = false;
        private bool _fastLoadingMode = false;

        // Dynamic chunk size based on configuration
        private int CurrentChunkSize => _progressiveLoadSize;

        // Light Mode (Official Telegram Light Theme)
        private readonly SolidColorBrush _lightBackground = new SolidColorBrush(Color.FromRgb(255, 255, 255)); // #FFFFFF
        private readonly SolidColorBrush _lightSecondaryBackground = new SolidColorBrush(Color.FromRgb(245, 245, 245)); // #F5F5F5
        private readonly SolidColorBrush _lightAccent = new SolidColorBrush(Color.FromRgb(42, 171, 238)); // #2AABEE
        private readonly SolidColorBrush _lightText = new SolidColorBrush(Color.FromRgb(51, 51, 51)); // #333333
        private readonly SolidColorBrush _lightSecondaryText = new SolidColorBrush(Color.FromRgb(140, 140, 140)); // #8C8C8C
        private readonly SolidColorBrush _lightMessageIncoming = new SolidColorBrush(Color.FromRgb(255, 255, 255)); // #FFFFFF
        private readonly SolidColorBrush _lightMessageOutgoing = new SolidColorBrush(Color.FromRgb(227, 242, 253)); // #E3F2FD
        private readonly SolidColorBrush _lightBorder = new SolidColorBrush(Color.FromRgb(224, 224, 224)); // #E0E0E0

        // Dark Mode (Official Telegram Dark Theme)
        private readonly SolidColorBrush _darkBackground = new SolidColorBrush(Color.FromRgb(32, 32, 32)); // #202020
        private readonly SolidColorBrush _darkSecondaryBackground = new SolidColorBrush(Color.FromRgb(43, 43, 43)); // #2B2B2B
        private readonly SolidColorBrush _darkAccent = new SolidColorBrush(Color.FromRgb(42, 171, 238)); // #2AABEE
        private readonly SolidColorBrush _darkText = new SolidColorBrush(Color.FromRgb(255, 255, 255)); // #FFFFFF
        private readonly SolidColorBrush _darkSecondaryText = new SolidColorBrush(Color.FromRgb(176, 176, 176)); // #B0B0B0
        private readonly SolidColorBrush _darkMessageIncoming = new SolidColorBrush(Color.FromRgb(59, 59, 59)); // #3B3B3B
        private readonly SolidColorBrush _darkMessageOutgoing = new SolidColorBrush(Color.FromRgb(0, 92, 152)); // #005C98
        private readonly SolidColorBrush _darkBorder = new SolidColorBrush(Color.FromRgb(64, 64, 64)); // #404040

        public MainWindow()
        {
            InitializeComponent();
            
            _logger = new Logger();
            _messageParser = new MessageParser(_logger);
            
            InitializeSearchTimer();
            InitializeScrollThrottleTimer();
            
            // Initialize theme resources early
            InitializeThemeResources();
            
            // Set window title with version
            var version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;
            if (version != null)
            {
                this.Title = $"Telegram Chat Viewer v{version.Major}.{version.Minor}.{version.Build}";
            }
            
            // Handle application closing
            this.Closing += MainWindow_Closing;
            
            // Ensure window is visible and properly positioned
            this.Loaded += MainWindow_Loaded;
            
            _logger.Info("Telegram Chat Viewer (C#) initialized successfully");
        }

        private void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            try
            {
                _logger.Info("MainWindow_Loaded event called");
                
                // Force window to be visible and bring to front
                this.Visibility = Visibility.Visible;
                this.Show();
                this.WindowState = WindowState.Normal;
                this.Activate();
                this.Focus();
                
                // Force window to front
                this.Topmost = true;
                this.Topmost = false;
                
                // Ensure window is centered and visible
                this.WindowStartupLocation = WindowStartupLocation.CenterScreen;
                this.Left = (SystemParameters.PrimaryScreenWidth - this.Width) / 2;
                this.Top = (SystemParameters.PrimaryScreenHeight - this.Height) / 2;
                
                _logger.Info($"Window positioned at ({this.Left}, {this.Top}) with size ({this.Width}, {this.Height})");
                _logger.Info($"Window state: {this.WindowState}, Visibility: {this.Visibility}");
            }
            catch (Exception ex)
            {
                _logger.Error($"Error in MainWindow_Loaded: {ex.Message}", ex);
                MessageBox.Show($"Error in MainWindow_Loaded: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void MainWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            _logger?.LogApplicationExit();
        }

        private void InitializeSearchTimer()
        {
            _searchTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromMilliseconds(500)
            };
            _searchTimer.Tick += (s, e) =>
            {
                _searchTimer.Stop();
                PerformSearch();
            };
        }

        private void InitializeScrollThrottleTimer()
        {
            _scrollThrottleTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromMilliseconds(ScrollThrottleMs)
            };
            _scrollThrottleTimer.Tick += (s, e) =>
            {
                _scrollThrottleTimer.Stop();
                CheckInfiniteScroll();
            };
        }

        private void InitializeThemeResources()
        {
            try
            {
                // Initialize theme resources to prevent resource not found errors
                var resources = this.Resources;
                
                // Set initial light theme resources
                resources["PrimaryBackground"] = _lightBackground;
                resources["SecondaryBackground"] = _lightSecondaryBackground;
                resources["MessageInBackground"] = _lightMessageIncoming;
                resources["MessageOutBackground"] = _lightMessageOutgoing;
                resources["ServiceBackground"] = new SolidColorBrush(Color.FromRgb(0xE5, 0xF3, 0xDF));
                resources["ReplyBackground"] = new SolidColorBrush(Color.FromRgb(0xF0, 0xF8, 0xEB));
                resources["AccentColor"] = _lightAccent;
                resources["PrimaryText"] = _lightText;
                resources["SecondaryText"] = _lightSecondaryText;
                resources["ServiceText"] = new SolidColorBrush(Color.FromRgb(0x7E, 0x9E, 0x87));
                resources["ReplyText"] = new SolidColorBrush(Color.FromRgb(0x70, 0x8B, 0x75));
                resources["WelcomeText"] = new SolidColorBrush(Color.FromRgb(0x2C, 0x55, 0x30));
                resources["WelcomeSecondary"] = new SolidColorBrush(Color.FromRgb(0x70, 0x8B, 0x75));
                resources["MessageAltBackground1"] = new SolidColorBrush(Color.FromRgb(0xE9, 0xF5, 0xE3));
                resources["MessageAltBackground2"] = new SolidColorBrush(Color.FromRgb(0xD6, 0xE8, 0xCE));
                
                _logger.Info("Theme resources initialized successfully");
            }
            catch (Exception ex)
            {
                _logger.Error($"Error initializing theme resources: {ex.Message}", ex);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private async void LoadButton_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new OpenFileDialog
            {
                Title = "Select Telegram Chat Export",
                Filter = "JSON files (*.json)|*.json|All files (*.*)|*.*",
                CheckFileExists = true
            };

            if (openFileDialog.ShowDialog() == true)
            {
                await LoadChatFile(openFileDialog.FileName);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private async Task LoadChatFile(string filePath)
        {
            try
            {
                _isInitialSetup = false; // Reset flag for new chat
                _jsonFileDirectory = Path.GetDirectoryName(Path.GetFullPath(filePath));
                _logger.Info($"JSON file directory set to: {_jsonFileDirectory}");

                var fileInfo = new FileInfo(filePath);
                var fileSizeMB = fileInfo.Length / (1024.0 * 1024.0);
                _logger.Info($"File size: {fileSizeMB:F2} MB");

                // Show loading UI
                ShowLoadingUI(true, "Analyzing file...");

                UpdateProgress(20, "Analyzing file...");

                // Get initial file analysis for the dialog
                var metadata = await _messageParser.GetChatMetadataAsync(filePath);
                
                // Show unified loading configuration dialog
                ShowLoadingUI(false); // Hide loading UI temporarily
                
                LoadingConfigDialog configDialog = null;
                try
                {
                    configDialog = new LoadingConfigDialog(filePath, fileSizeMB, metadata.TotalMessages, _isLightMode);
                    configDialog.Owner = this;
                    
                    var dialogResult = configDialog.ShowDialog();
                    if (dialogResult != true || configDialog.WasCancelled)
                    {
                        ShowLoadingUI(false); // Clear any status messages
                        return; // User cancelled
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
                catch (Exception dialogEx)
                {
                    _logger.Error($"Error creating or showing loading configuration dialog: {dialogEx.Message}", dialogEx);
                    
                    // Fallback to default settings if dialog fails
                    MessageBox.Show($"Error with loading dialog: {dialogEx.Message}\n\nUsing default loading settings.", 
                        "Dialog Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                    
                    // Create a default config and continue
                    var defaultConfig = new LoadingConfig
                    {
                        LoadingStrategy = metadata.TotalMessages > 10000 ? LoadingStrategy.Progressive : LoadingStrategy.LoadAll,
                        ChunkSize = 1000,
                        UseMassiveLoad = metadata.TotalMessages > 10000,
                        UseVirtualScrolling = metadata.TotalMessages > 50000,
                        UseAlternatingLayout = false,
                        UseAlternatingBackgrounds = true
                    };
                    
                    // Apply default configuration
                    _useVirtualScrolling = defaultConfig.UseVirtualScrolling;
                    _useMassiveLoad = defaultConfig.UseMassiveLoad;
                    _useAlternatingLayout = defaultConfig.UseAlternatingLayout;
                    _useAlternatingBackgrounds = defaultConfig.UseAlternatingBackgrounds;
                    _progressiveLoadSize = defaultConfig.ChunkSize;
                    
                    // Continue with loading using defaults
                    ShowLoadingUI(true, "Loading messages...");
                    UpdateProgress(30, "Loading messages...");
                    
                    // Use standard loading approach
                    var (messages, chatName) = await _messageParser.LoadChatFileAsync(filePath);
                    _allMessages = messages;
                    _chatName = chatName;
                    
                    UpdateProgress(70, $"Loaded {messages.Count:N0} messages...");

                    // Setup loading based on default strategy
                    if (defaultConfig.LoadingStrategy == LoadingStrategy.Progressive)
                    {
                        _logger.Info($"Using progressive loading for {_allMessages.Count} messages with chunk size {defaultConfig.ChunkSize}");
                        _infiniteScrollEnabled = true;
                        _progressiveLoadSize = defaultConfig.ChunkSize;

                        // Load initial chunk
                        var initialChunkSize = Math.Min(defaultConfig.ChunkSize, _allMessages.Count);
                        _currentMessages = _allMessages.Take(initialChunkSize).ToList();
                        _currentChunkIndex = initialChunkSize;
                    }
                    else // LoadAll
                    {
                        _logger.Info($"Loading all {_allMessages.Count} messages at once");
                        _currentMessages = _allMessages;
                        _infiniteScrollEnabled = false;
                    }

                    // Reset member colors
                    _memberColors.Clear();

                    UpdateProgress(90, "Rendering messages...");

                    // Setup UI
                    await SetupChatUI();

                    UpdateProgress(100, "Complete!");
                    _logger.Info("Chat loading completed successfully with default settings");

                    await Task.Delay(1000);
                    ShowLoadingUI(false);
                    return;
                }

                var config = configDialog.Result;
                
                // Apply configuration settings
                _useVirtualScrolling = config.UseVirtualScrolling;
                _useMassiveLoad = config.UseMassiveLoad;
                _useAlternatingLayout = config.UseAlternatingLayout;
                _useAlternatingBackgrounds = config.UseAlternatingBackgrounds;
                
                // Update menu items to reflect settings
                AlternatingLayoutMenuItem.IsChecked = _useAlternatingLayout;
                AlternatingBackgroundMenuItem.IsChecked = _useAlternatingBackgrounds;

                // Show loading UI again
                ShowLoadingUI(true, "Loading messages...");
                UpdateProgress(30, "Loading messages...");

                // Load messages based on strategy
                if (config.LoadingStrategy == LoadingStrategy.Streaming)
                {
                    // Use streaming approach for very large files
                    _logger.Info($"Using streaming loading strategy with chunk size {config.ChunkSize}");
                    var streamingResult = await _messageParser.LoadChatFileStreamingAsync(filePath, config.ChunkSize);
                    
                    var allMessages = new List<TelegramMessage>();
                    await foreach (var chunk in streamingResult.messageChunks)
                    {
                        allMessages.AddRange(chunk);
                        UpdateProgress(30 + (allMessages.Count * 40.0 / metadata.TotalMessages), 
                                     $"Loaded {allMessages.Count:N0}/{metadata.TotalMessages:N0} messages...");
                    }
                    
                    _allMessages = allMessages;
                    _chatName = streamingResult.chatName;
                    _infiniteScrollEnabled = true;
                    _progressiveLoadSize = config.ChunkSize;
                    
                    // Load initial chunk
                    var initialChunkSize = Math.Min(config.ChunkSize, _allMessages.Count);
                    _currentMessages = _allMessages.Take(initialChunkSize).ToList();
                    _currentChunkIndex = initialChunkSize;
                }
                else
                {
                    // Use standard loading
                    var (messages, chatName) = await _messageParser.LoadChatFileAsync(filePath);
                    _allMessages = messages;
                    _chatName = chatName;
                    
                    UpdateProgress(70, $"Loaded {messages.Count:N0} messages...");

                    // Setup loading based on strategy
                    if (config.LoadingStrategy == LoadingStrategy.Progressive)
                    {
                        _logger.Info($"Using progressive loading for {_allMessages.Count} messages with chunk size {config.ChunkSize}");
                        _infiniteScrollEnabled = true;
                        _progressiveLoadSize = config.ChunkSize;

                        // Load initial chunk
                        var initialChunkSize = Math.Min(config.ChunkSize, _allMessages.Count);
                        _currentMessages = _allMessages.Take(initialChunkSize).ToList();
                        _currentChunkIndex = initialChunkSize;
                    }
                    else // LoadAll
                    {
                        _logger.Info($"Loading all {_allMessages.Count} messages at once");
                        _currentMessages = _allMessages;
                        _infiniteScrollEnabled = false;
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

                // Reset member colors
                _memberColors.Clear();

                UpdateProgress(90, "Rendering messages...");

                // Setup UI
                await SetupChatUI();

                UpdateProgress(100, "Complete!");
                _logger.Info("Chat loading completed successfully");

                await Task.Delay(1000);
                ShowLoadingUI(false);
            }
            catch (Exception ex)
            {
                _logger.Error($"Error loading chat file: {filePath}", ex);
                ShowLoadingUI(false);
                MessageBox.Show($"Failed to load chat file:\n\n{ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private async Task SetupChatUI()
        {
            _isInitialSetup = true; // Prevent infinite scroll during initial setup
            
            // Update status
            StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages";

            // Show chat panel
            WelcomePanel.Visibility = Visibility.Collapsed;
            ChatPanel.Visibility = Visibility.Visible;

            // Setup progressive infinite scroll event handling if enabled
            if (_infiniteScrollEnabled)
            {
                ChatScrollViewer.ScrollChanged += ChatScrollViewer_ScrollChanged;
                _logger.Info($"Progressive infinite scroll enabled for {_allMessages.Count} messages (chunk size: {CurrentChunkSize})");
            }

            // Setup virtual scrolling if needed (for extremely large files)
            if (_useVirtualScrolling && _currentMessages.Count > 50000)
            {
                _logger.Info("Setting up virtual scrolling for extremely large file");
                _virtualScrollManager = new VirtualScrollManager(ChatScrollViewer, MessagesContainer, _logger);
                _virtualScrollManager.SetMessages(_currentMessages);

                if (_infiniteScrollEnabled)
                {
                    // Create a wrapper method for the virtual scroll manager
                    _virtualScrollManager.EnableInfiniteScroll(() => LoadMoreMessagesAsync());
                    _virtualScrollManager.SetHasMoreMessages(_currentChunkIndex < _allMessages.Count);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            else
            {
                _logger.Info("Using standard message rendering");
                await RenderAllMessages();
            }
            
            // Initialize scroll position tracking
            _lastScrollPosition = 0;
            _previousScrollPosition = 0;
            _lastScrollTrigger = DateTime.MinValue;
            _isScrollingDown = true;
            
            // Allow some time for UI to settle, then enable infinite scroll
            await Task.Delay(500);
            _isInitialSetup = false;
            _logger.Info("Initial setup complete, infinite scroll enabled");
        }

        private void ChatScrollViewer_ScrollChanged(object sender, ScrollChangedEventArgs e)
        {
            // Early exit conditions
            if (!_infiniteScrollEnabled || _isLoadingMore || _isInitialSetup)
                return;
                
            // Store current scroll position and determine direction
            var scrollViewer = sender as ScrollViewer;
            if (scrollViewer?.ScrollableHeight > 0)
            {
                var currentPosition = scrollViewer.VerticalOffset / scrollViewer.ScrollableHeight;
                
                // Determine scroll direction
                _isScrollingDown = currentPosition > _previousScrollPosition;
                _previousScrollPosition = currentPosition;
                _lastScrollPosition = currentPosition;
            }
            else if (scrollViewer?.ScrollableHeight == 0)
            {
                // Handle case where all content fits in viewport but we still have more messages
                _lastScrollPosition = 1.0; // Consider it at the bottom
                _isScrollingDown = true;
            }

            // Throttle scroll events - restart timer on each scroll
            _scrollThrottleTimer.Stop();
            _scrollThrottleTimer.Start();
        }

        private void CheckInfiniteScroll()
        {
            // Early exit conditions
            if (!_infiniteScrollEnabled || _isLoadingMore || _isInitialSetup)
                return;
                
            // Check if we have more messages to load
            if (_currentChunkIndex >= _allMessages.Count)
            {
                _logger.Debug("No more messages to load, infinite scroll disabled");
                _infiniteScrollEnabled = false;
                return;
            }

            var scrollViewer = ChatScrollViewer;
            
            // Improved scroll trigger detection
            bool shouldTriggerLoad = false;
            
            if (scrollViewer.ScrollableHeight == 0)
            {
                // All content fits in viewport, but we have more messages - load more
                shouldTriggerLoad = true;
                _logger.Debug("Content fits in viewport, triggering load for more messages");
            }
            else if (_lastScrollPosition >= 0.90) // Trigger at 90% scroll (less aggressive)
            {
                // Traditional scroll-based trigger - made less aggressive
                shouldTriggerLoad = true;
                _logger.Debug($"Scroll trigger at position {_lastScrollPosition:F3}");
            }
            else if (scrollViewer.VerticalOffset >= scrollViewer.ScrollableHeight - 100) // Within 100px of bottom
            {
                // Pixel-based trigger for edge cases
                shouldTriggerLoad = true;
                _logger.Debug($"Pixel-based trigger: {scrollViewer.VerticalOffset}/{scrollViewer.ScrollableHeight}");
            }

            if (!shouldTriggerLoad)
                return;

            // Check cooldown period to prevent rapid consecutive loads
            var timeSinceLastTrigger = DateTime.Now - _lastScrollTrigger;
            if (timeSinceLastTrigger.TotalMilliseconds < ScrollCooldownMs)
            {
                _logger.Debug($"Infinite scroll cooldown active: {timeSinceLastTrigger.TotalMilliseconds:F0}ms remaining");
                return;
            }

            _lastScrollTrigger = DateTime.Now;
            _logger.Info($"Infinite scroll triggered at position {_lastScrollPosition:F3}");
            
            // Fire and forget the async loading operation
            _ = LoadMoreMessagesAsync();
        }

        private async Task LoadMoreMessagesAsync()
        {
            // Double-check conditions with lock-like behavior
            if (_isLoadingMore || _currentChunkIndex >= _allMessages.Count)
                return;

            // Set loading state immediately to prevent concurrent calls
            _isLoadingMore = true;
            
            try
            {
                // Show loading indicator
                InfiniteScrollLoader.Visibility = Visibility.Visible;
                
                _logger.Info($"Loading more messages: current index {_currentChunkIndex}/{_allMessages.Count}");

                var remainingMessages = _allMessages.Count - _currentChunkIndex;
                
                // Use the correct chunk size (massive load if enabled)
                var messagesToLoad = Math.Min(CurrentChunkSize, remainingMessages);

                if (messagesToLoad <= 0)
                {
                    _logger.Info("No more messages to load");
                    return;
                }

                // Remember current scroll position for maintaining scroll
                var scrollViewer = ChatScrollViewer;
                var currentScrollPosition = scrollViewer.VerticalOffset;
                var currentScrollHeight = scrollViewer.ScrollableHeight;

                // Get new messages
                var newMessages = _allMessages.Skip(_currentChunkIndex).Take(messagesToLoad).ToList();
                _currentMessages.AddRange(newMessages);
                _currentChunkIndex += messagesToLoad;

                // Render new messages with progress updates
                await RenderNewMessagesWithProgress(newMessages);

                // Update status
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages";

                // Maintain scroll position (prevent jumping) - improved logic
                await Task.Delay(100); // Allow UI to settle
                var newScrollHeight = scrollViewer.ScrollableHeight;
                if (newScrollHeight > currentScrollHeight)
                {
                    // Calculate the relative position to maintain
                    var scrollRatio = currentScrollPosition / Math.Max(currentScrollHeight, 1);
                    var targetOffset = scrollRatio * newScrollHeight;
                    
                    // Only adjust position if we're not at the very bottom
                    // This prevents auto-scrolling to bottom when user isn't there
                    if (scrollRatio < 0.98) // Allow some tolerance for "at bottom"
                    {
                        // Temporarily disable infinite scroll during position adjustment
                        var wasInfiniteScrollEnabled = _infiniteScrollEnabled;
                        _infiniteScrollEnabled = false;
                        
                        // Maintain original scroll ratio
                        scrollViewer.ScrollToVerticalOffset(targetOffset);
                        
                        // Wait for scroll to settle, then re-enable infinite scroll
                        await Task.Delay(300);
                        _infiniteScrollEnabled = wasInfiniteScrollEnabled;
                        
                        // Update our tracking variables to reflect the new position
                        _lastScrollPosition = targetOffset / Math.Max(newScrollHeight, 1);
                        _previousScrollPosition = _lastScrollPosition;
                        
                        _logger.Debug($"Maintained scroll position: ratio {scrollRatio:F3}, new position {_lastScrollPosition:F3}");
                    }
                    else
                    {
                        // User was at the bottom, let them stay at the bottom naturally
                        // but don't force scroll to bottom - let the content flow naturally
                        _logger.Debug("User was at bottom, allowing natural scroll behavior");
                        
                        // Brief pause to prevent immediate infinite scroll triggers
                        await Task.Delay(300);
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

                _logger.Info($"Loaded {messagesToLoad} more messages (chunk size: {CurrentChunkSize}). Total: {_currentMessages.Count}/{_allMessages.Count}");
                
                // Check if we've loaded all messages
                if (_currentChunkIndex >= _allMessages.Count)
                {
                    _logger.Info("All messages loaded, disabling infinite scroll");
                    _infiniteScrollEnabled = false;
                    // Update title when all messages are loaded
                    StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages";
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            catch (Exception ex)
            {
                _logger.Error("Error loading more messages", ex);
                // Show error to user
                MessageBox.Show($"Error loading more messages: {ex.Message}", "Loading Error", 
                    MessageBoxButton.OK, MessageBoxImage.Warning);
            }
            finally
            {
                _isLoadingMore = false;
                // Hide loading indicator
                InfiniteScrollLoader.Visibility = Visibility.Collapsed;
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private async Task RenderNewMessagesWithProgress(List<TelegramMessage> newMessages)
        {
            // Show progress for large batches
            var showProgress = newMessages.Count > 500; // Reduced threshold
            var progressInterval = Math.Max(1, newMessages.Count / 20); // More frequent updates
            
            var currentDate = DateTime.MinValue;
            string currentMember = null;
            StackPanel currentMemberGroup = null;
            int messageIndex = _currentMessages.Count - newMessages.Count;
            string lastSender = null;
            bool isAlternatingLeft = true;
            
            // Track user alternating state
            bool useAlternateUserBackground = false;

            // Get the last date and member from existing messages for proper continuation
            if (MessagesContainer.Children.Count > 0)
            {
                var lastMessage = _currentMessages[_currentMessages.Count - newMessages.Count - 1];
                currentDate = lastMessage.ParsedDate.Date;
                currentMember = lastMessage.DisplaySender;
                lastSender = currentMember;
                
                // Calculate current alternating states
                if (_useAlternatingLayout)
                {
                    var senderChanges = 0;
                    string prevSender = null;
                    for (int i = 0; i < _currentMessages.Count - newMessages.Count; i++)
                    {
                        var msg = _currentMessages[i];
                        if (!msg.IsServiceMessage)
                        {
                            if (prevSender != null && prevSender != msg.DisplaySender)
                            {
                                senderChanges++;
                            }
                            prevSender = msg.DisplaySender;
                            private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
                    isAlternatingLeft = (senderChanges % 2 == 0);
                }
                
                if (_useAlternatingBackgrounds)
                {
                    var userChanges = 0;
                    string prevUser = null;
                    for (int i = 0; i < _currentMessages.Count - newMessages.Count; i++)
                    {
                        var msg = _currentMessages[i];
                        if (!msg.IsServiceMessage)
                        {
                            if (prevUser != null && prevUser != msg.DisplaySender)
                            {
                                userChanges++;
                            }
                            prevUser = msg.DisplaySender;
                            private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
                    useAlternateUserBackground = (userChanges % 2 == 1);
                }
                
                // Find the last member group for continuation
                for (int i = MessagesContainer.Children.Count - 1; i >= 0; i--)
                {
                    if (MessagesContainer.Children[i] is StackPanel panel && 
                        panel.Children.Count > 0 && 
                        panel.Children[0] is StackPanel headerPanel &&
                        headerPanel.Children.Count > 0 &&
                        headerPanel.Children[0] is TextBlock memberLabel &&
                        memberLabel.Text == currentMember)
                    {
                        currentMemberGroup = panel;
                        break;
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            }

            // Process messages with periodic UI updates
            for (int i = 0; i < newMessages.Count; i++)
            {
                var message = newMessages[i];
                
                // Add date separator if date changed
                var messageDate = message.ParsedDate.Date;
                if (messageDate != currentDate)
                {
                    currentDate = messageDate;
                    currentMember = null;
                    currentMemberGroup = null;
                    AddDateSeparator(messageDate);
                }

                // Handle message based on type
                if (message.IsServiceMessage)
                {
                    currentMember = null;
                    currentMemberGroup = null;
                    AddServiceMessage(message, messageIndex, useAlternateUserBackground);
                }
                else
                {
                    var sender = message.DisplaySender;

                    // For alternating layout, determine side based on sender change
                    if (_useAlternatingLayout)
                    {
                        if (lastSender != null && lastSender != sender)
                        {
                            isAlternatingLeft = !isAlternatingLeft;
                        }
                        lastSender = sender;
                    }
                    
                    // For user-based alternating backgrounds
                    if (_useAlternatingBackgrounds && lastSender != null && lastSender != sender)
                    {
                        useAlternateUserBackground = !useAlternateUserBackground;
                    }

                    // Check if we need a new member group
                    if (currentMember != sender)
                    {
                        currentMember = sender;
                        currentMemberGroup = CreateMemberGroup(sender, messageIndex);
                    }

                    // Add message to current group
                    AddMessageToGroup(message, currentMemberGroup, sender, messageIndex, isAlternatingLeft, useAlternateUserBackground);
                }

                messageIndex++;

                // Batch UI updates for better performance
                if (showProgress && i % progressInterval == 0)
                {
                    var progress = (double)i / newMessages.Count * 100;
                    StatusLabel.Text = $"Loading messages... {progress:F0}%";
                    await Task.Delay(1); // Allow UI to update
                }
                else if (i % 100 == 0) // Reduced frequency from 50 to 100
                {
                    await Task.Delay(1); // Standard UI update interval
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            
            // Clear progress status
            if (showProgress)
            {
                StatusLabel.Text = "";
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private async Task RenderNewMessagesOptimized(List<TelegramMessage> newMessages)
        {
            const int batchSize = 100;
            var batches = newMessages.Select((message, index) => new { message, index })
                                    .GroupBy(x => x.index / batchSize)
                                    .Select(g => g.Select(x => x.message).ToList())
                                    .ToList();

            var showProgress = newMessages.Count > 500;
            
            for (int batchIndex = 0; batchIndex < batches.Count; batchIndex++)
            {
                var batch = batches[batchIndex];
                var elementsToAdd = new List<FrameworkElement>();
                
                // Process batch off the UI thread
                await Task.Run(() =>
                {
                    // Pre-calculate layout state for the batch
                    var currentDate = DateTime.MinValue;
                    string currentMember = null;
                    int messageIndex = _currentMessages.Count - newMessages.Count + (batchIndex * batchSize);
                    
                    // Process messages in the batch
                    foreach (var message in batch)
                    {
                        var messageDate = message.ParsedDate.Date;
                        if (messageDate != currentDate)
                        {
                            currentDate = messageDate;
                            currentMember = null;
                            // We'll handle date separators on the UI thread
                        }

                        if (!message.IsServiceMessage)
                        {
                            var sender = message.DisplaySender;
                            if (currentMember != sender)
                            {
                                currentMember = sender;
                                // We'll handle member groups on the UI thread
                                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
                        messageIndex++;
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
});

                // Add batch to UI thread
                foreach (var message in batch)
                {
                    var messageDate = message.ParsedDate.Date;
                    // Handle date separator and message rendering as before
                    // This part needs to stay on UI thread due to WPF requirements
                }

                // Update progress
                if (showProgress)
                {
                    var progress = (double)(batchIndex + 1) / batches.Count * 100;
                    StatusLabel.Text = $"Loading messages... {progress:F0}%";
                }

                // Yield control to UI thread
                await Task.Delay(1);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private async Task RenderAllMessages()
        {
            MessagesContainer.Children.Clear();

            var currentDate = DateTime.MinValue;
            string currentMember = null;
            StackPanel currentMemberGroup = null;
            int messageIndex = 0;
            string lastSender = null;
            bool isAlternatingLeft = true; // For alternating layout
            
            // Track user alternating state
            bool useAlternateUserBackground = false;

            foreach (var message in _currentMessages)
            {
                // Add date separator if date changed
                var messageDate = message.ParsedDate.Date;
                if (messageDate != currentDate)
                {
                    currentDate = messageDate;
                    currentMember = null;
                    currentMemberGroup = null;
                    AddDateSeparator(messageDate);
                }

                // Handle message based on type
                if (message.IsServiceMessage)
                {
                    currentMember = null;
                    currentMemberGroup = null;
                    AddServiceMessage(message, messageIndex, useAlternateUserBackground);
                }
                else
                {
                    var sender = message.DisplaySender;

                    // For alternating layout, determine side based on sender change
                    if (_useAlternatingLayout)
                    {
                        if (lastSender != null && lastSender != sender)
                        {
                            isAlternatingLeft = !isAlternatingLeft;
                        }
                        lastSender = sender;
                    }
                    
                    // For user-based alternating backgrounds
                    if (_useAlternatingBackgrounds && lastSender != null && lastSender != sender)
                    {
                        useAlternateUserBackground = !useAlternateUserBackground;
                    }

                    // Check if we need a new member group
                    if (currentMember != sender)
                    {
                        currentMember = sender;
                        currentMemberGroup = CreateMemberGroup(sender, messageIndex);
                    }

                    // Add message to current group
                    AddMessageToGroup(message, currentMemberGroup, sender, messageIndex, isAlternatingLeft, useAlternateUserBackground);
                }

                messageIndex++;

                // Allow UI to update periodically
                if (MessagesContainer.Children.Count % 100 == 0)
                {
                    await Task.Delay(1);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

            // Start from the top instead of scrolling to bottom
            await Task.Delay(100);
            ChatScrollViewer.ScrollToTop();
        }

        private void AddDateSeparator(DateTime date)
        {
            var dateText = date.ToString("MMMM dd, yyyy");
            
            var dateContainer = new Border
            {
                Background = FindResource("PrimaryBackground") as Brush,
                CornerRadius = new CornerRadius(12),
                Padding = new Thickness(12, 6, 12, 6),
                Margin = new Thickness(0, 15, 0, 10),
                HorizontalAlignment = HorizontalAlignment.Center
            };

            var dateLabel = new TextBlock
            {
                Text = dateText,
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 12,
                Foreground = FindResource("SecondaryText") as Brush,
                HorizontalAlignment = HorizontalAlignment.Center
            };

            dateContainer.Child = dateLabel;
            MessagesContainer.Children.Add(dateContainer);
        }

        private StackPanel CreateMemberGroup(string memberName, int messageIndex)
        {
            var memberContainer = new StackPanel
            {
                Margin = new Thickness(5, 8, 5, 2)
            };

            // Don't apply alternating background to the container anymore
            // Background will be applied to individual message bubbles instead

            // Member header
            var headerPanel = new StackPanel
            {
                Orientation = Orientation.Horizontal,
                Margin = new Thickness(10, 0, 0, 3)
            };

            var memberColor = GetMemberColor(memberName);
            var memberLabel = new TextBlock
            {
                Text = memberName,
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 13,
                FontWeight = FontWeights.Bold,
                Foreground = memberColor
            };

            headerPanel.Children.Add(memberLabel);
            memberContainer.Children.Add(headerPanel);

            MessagesContainer.Children.Add(memberContainer);
            return memberContainer;
        }

        private void AddMessageToGroup(TelegramMessage message, StackPanel memberGroup, string sender, int messageIndex, bool isAlternatingLeft, bool useAlternateUserBackground)
        {
            var messageContainer = new Grid
            {
                Margin = new Thickness(0, 1, 0, 1)
            };

            // Update member name alignment to match message alignment
            if (memberGroup.Children.Count > 0 && memberGroup.Children[0] is StackPanel headerPanel)
            {
                if (_useAlternatingLayout)
                {
                    // Align member name with message position
                    if (isAlternatingLeft)
                    {
                        headerPanel.HorizontalAlignment = HorizontalAlignment.Left;
                        headerPanel.Margin = new Thickness(10, 0, 0, 3);
                    }
                    else
                    {
                        headerPanel.HorizontalAlignment = HorizontalAlignment.Right;
                        headerPanel.Margin = new Thickness(0, 0, 10, 3);
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
                else
                {
                    // Original layout: based on outgoing/incoming
                    if (message.IsOutgoing)
                    {
                        headerPanel.HorizontalAlignment = HorizontalAlignment.Right;
                        headerPanel.Margin = new Thickness(0, 0, 10, 3);
                    }
                    else
                    {
                        headerPanel.HorizontalAlignment = HorizontalAlignment.Left;
                        headerPanel.Margin = new Thickness(10, 0, 0, 3);
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            }

            // Create message bubble with background alternation (use simplified version in fast loading mode)
            var bubble = _fastLoadingMode 
                ? CreateSimplifiedMessageBubble(message, useAlternateUserBackground)
                : CreateMessageBubble(message, sender, messageIndex, useAlternateUserBackground);
            
            // Determine alignment based on layout mode
            if (_useAlternatingLayout)
            {
                // Alternating layout: alternate sides based on sender changes
                if (isAlternatingLeft)
                {
                    messageContainer.HorizontalAlignment = HorizontalAlignment.Left;
                    bubble.HorizontalAlignment = HorizontalAlignment.Left;
                    bubble.Margin = new Thickness(5, 0, 50, 0);
                }
                else
                {
                    messageContainer.HorizontalAlignment = HorizontalAlignment.Right;
                    bubble.HorizontalAlignment = HorizontalAlignment.Right;
                    bubble.Margin = new Thickness(50, 0, 5, 0);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            else
            {
                // Original layout: based on outgoing/incoming
                if (message.IsOutgoing)
                {
                    messageContainer.HorizontalAlignment = HorizontalAlignment.Right;
                    bubble.HorizontalAlignment = HorizontalAlignment.Right;
                    bubble.Margin = new Thickness(50, 0, 5, 0);
                }
                else
                {
                    messageContainer.HorizontalAlignment = HorizontalAlignment.Left;
                    bubble.HorizontalAlignment = HorizontalAlignment.Left;
                    bubble.Margin = new Thickness(5, 0, 50, 0);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

            messageContainer.Children.Add(bubble);
            memberGroup.Children.Add(messageContainer);
        }

        private Border CreateMessageBubble(TelegramMessage message, string sender, int messageIndex, bool useAlternateUserBackground)
        {
            var bubbleBackground = message.IsOutgoing 
                ? GetCachedResource("MessageOutBackground")
                : GetCachedResource("MessageInBackground");

            // Apply user-based alternating background if enabled
            if (_useAlternatingBackgrounds)
            {
                bubbleBackground = useAlternateUserBackground 
                    ? GetCachedResource("MessageAltBackground2")
                    : GetCachedResource("MessageAltBackground1");
            }

            var bubble = new Border
            {
                Background = bubbleBackground,
                CornerRadius = new CornerRadius(12),
                Padding = new Thickness(12, 8, 12, 8),
                MaxWidth = 600
            };

            var contentPanel = new StackPanel();

            // Add forwarded indicator if needed
            if (message.IsForwarded)
            {
                AddForwardedIndicator(contentPanel, message.ForwardedFrom, bubbleBackground);
            }

            // Add reply block if needed
            if (message.IsReply)
            {
                var originalMessage = _messageParser.FindOriginalMessage(_allMessages, message.ReplyToMessageId.Value);
                if (originalMessage != null)
                {
                    AddReplyBlock(contentPanel, originalMessage, bubbleBackground);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

            // Add media if present
            if (message.HasMedia)
            {
                var mediaInfo = MessageParser.GetMediaInfo(message);
                if (mediaInfo != null)
                {
                    AddMediaContent(contentPanel, mediaInfo, bubbleBackground);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

            // Add text content if present
            if (!string.IsNullOrEmpty(message.PlainText))
            {
                AddFormattedText(contentPanel, message, bubbleBackground);
            }

            // Add timestamp
            var timeText = message.ParsedDate.ToString("HH:mm");
            var timeLabel = new TextBlock
            {
                Text = timeText,
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 10,
                Foreground = GetCachedResource("SecondaryText"),
                HorizontalAlignment = HorizontalAlignment.Right,
                Margin = new Thickness(0, 4, 0, 0)
            };

            contentPanel.Children.Add(timeLabel);
            bubble.Child = contentPanel;

            return bubble;
        }

        private void AddServiceMessage(TelegramMessage message, int messageIndex, bool useAlternateUserBackground)
        {
            var serviceText = MessageParser.FormatServiceMessage(
                message.Actor, message.Action, message.Title, message.Members);

            var serviceBackground = GetCachedResource("ServiceBackground");

            // Apply user-based alternating background if enabled
            if (_useAlternatingBackgrounds)
            {
                serviceBackground = useAlternateUserBackground 
                    ? GetCachedResource("MessageAltBackground2")
                    : GetCachedResource("MessageAltBackground1");
            }

            var serviceContainer = new Border
            {
                Background = serviceBackground,
                CornerRadius = new CornerRadius(8),
                Padding = new Thickness(12, 6, 12, 6),
                Margin = new Thickness(10, 8, 10, 8),
                HorizontalAlignment = HorizontalAlignment.Center
            };

            var serviceLabel = new TextBlock
            {
                Text = serviceText,
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 11,
                FontStyle = FontStyles.Italic,
                Foreground = GetCachedResource("ServiceText"),
                TextAlignment = TextAlignment.Center,
                TextWrapping = TextWrapping.Wrap
            };

            serviceContainer.Child = serviceLabel;
            MessagesContainer.Children.Add(serviceContainer);
        }

        private void AddForwardedIndicator(StackPanel parent, string forwardedFrom, Brush background)
        {
            var forwardLabel = new TextBlock
            {
                Text = $"↗️ Forwarded from {forwardedFrom}",
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 11,
                FontStyle = FontStyles.Italic,
                Foreground = GetCachedResource("SecondaryText"),
                Margin = new Thickness(0, 0, 0, 6)
            };

            parent.Children.Add(forwardLabel);
        }

        private void AddReplyBlock(StackPanel parent, TelegramMessage originalMessage, Brush background)
        {
            var replyContainer = new Border
            {
                Background = GetCachedResource("ReplyBackground"),
                CornerRadius = new CornerRadius(6),
                Padding = new Thickness(8, 6, 8, 6),
                Margin = new Thickness(0, 0, 0, 8)
            };

            var replyPanel = new StackPanel
            {
                Orientation = Orientation.Horizontal
            };

            // Color bar
            var colorBar = new Border
            {
                Width = 3,
                Background = GetMemberColor(originalMessage.DisplaySender),
                Margin = new Thickness(0, 0, 8, 0)
            };

            var replyContent = new StackPanel();

            // Original sender
            var senderLabel = new TextBlock
            {
                Text = originalMessage.DisplaySender,
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 11,
                FontWeight = FontWeights.Bold,
                Foreground = GetMemberColor(originalMessage.DisplaySender)
            };

            // Preview text
            var previewText = MessageParser.GetReplyPreviewText(originalMessage, 60);
            var previewLabel = new TextBlock
            {
                Text = previewText,
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 11,
                Foreground = GetCachedResource("ReplyText"),
                TextWrapping = TextWrapping.Wrap
            };

            replyContent.Children.Add(senderLabel);
            replyContent.Children.Add(previewLabel);

            replyPanel.Children.Add(colorBar);
            replyPanel.Children.Add(replyContent);

            replyContainer.Child = replyPanel;
            parent.Children.Add(replyContainer);
        }

        private void AddMediaContent(StackPanel parent, MediaInfo mediaInfo, Brush background)
        {
            var mediaContainer = new StackPanel
            {
                Margin = new Thickness(0, 0, 0, 8)
            };

            // Try to load and display media
            if (mediaInfo.Type == "photo" && TryLoadImage(mediaInfo.FilePath, out var imageSource))
            {
                var image = new Image
                {
                    Source = imageSource,
                    MaxWidth = 400,
                    MaxHeight = 300,
                    Stretch = Stretch.Uniform,
                    Cursor = Cursors.Hand
                };

                image.MouseLeftButtonUp += (s, e) => OpenFile(mediaInfo.FilePath);
                mediaContainer.Children.Add(image);
            }
            else if (mediaInfo.Type == "sticker")
            {
                // Handle stickers
                var stickerText = !string.IsNullOrEmpty(mediaInfo.StickerEmoji) 
                    ? $"{mediaInfo.StickerEmoji} Sticker" 
                    : "😀 Sticker";

                var stickerLabel = new TextBlock
                {
                    Text = stickerText,
                    FontFamily = new FontFamily("Segoe UI"),
                    FontSize = 24,
                    HorizontalAlignment = HorizontalAlignment.Center,
                    Cursor = Cursors.Hand
                };

                stickerLabel.MouseLeftButtonUp += (s, e) => OpenFile(mediaInfo.FilePath);
                mediaContainer.Children.Add(stickerLabel);
            }
            else
            {
                // Generic media placeholder
                var mediaIcon = GetMediaIcon(mediaInfo.Type);
                var mediaLabel = new TextBlock
                {
                    Text = $"{mediaIcon} {mediaInfo.Type.Replace("_", " ")}",
                    FontFamily = new FontFamily("Segoe UI"),
                    FontSize = 12,
                    Foreground = FindResource("PrimaryText") as Brush,
                    Cursor = Cursors.Hand
                };

                mediaLabel.MouseLeftButtonUp += (s, e) => OpenFile(mediaInfo.FilePath);
                mediaContainer.Children.Add(mediaLabel);

                // Add media info
                var infoParts = new List<string>();
                if (mediaInfo.FileSize > 0)
                    infoParts.Add(MessageParser.FormatFileSize(mediaInfo.FileSize));
                if (mediaInfo.Duration > 0)
                    infoParts.Add(MessageParser.FormatDuration(mediaInfo.Duration));
                if (mediaInfo.Width > 0 && mediaInfo.Height > 0)
                    infoParts.Add($"{mediaInfo.Width}×{mediaInfo.Height}");

                if (infoParts.Any())
                {
                    var infoLabel = new TextBlock
                    {
                        Text = string.Join(" • ", infoParts),
                        FontFamily = new FontFamily("Segoe UI"),
                        FontSize = 10,
                        Foreground = FindResource("SecondaryText") as Brush,
                        Margin = new Thickness(0, 2, 0, 0)
                    };

                    mediaContainer.Children.Add(infoLabel);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

            parent.Children.Add(mediaContainer);
        }

        private void AddFormattedText(StackPanel parent, TelegramMessage message, Brush background)
        {
            var textBlock = new TextBlock
            {
                FontFamily = new FontFamily("Segoe UI"),
                FontSize = 13,
                Foreground = FindResource("PrimaryText") as Brush,
                TextWrapping = TextWrapping.Wrap,
                LineHeight = 18
            };

            var formattedParts = message.FormattedText;
            
            foreach (var part in formattedParts)
            {
                // Check if we need to highlight search terms
                if (!string.IsNullOrEmpty(_currentSearchTerm) && 
                    part.Text.ToLowerInvariant().Contains(_currentSearchTerm.ToLowerInvariant()))
                {
                    AddHighlightedText(textBlock, part, _currentSearchTerm);
                }
                else
                {
                    AddFormattedRun(textBlock, part);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

            parent.Children.Add(textBlock);
        }

        private void AddHighlightedText(TextBlock textBlock, FormattedTextPart part, string searchTerm)
        {
            var text = part.Text;
            var lowerText = text.ToLowerInvariant();
            var lowerSearchTerm = searchTerm.ToLowerInvariant();
            
            int startIndex = 0;
            int foundIndex;
            
            while ((foundIndex = lowerText.IndexOf(lowerSearchTerm, startIndex)) != -1)
            {
                // Add text before the match
                if (foundIndex > startIndex)
                {
                    var beforeText = text.Substring(startIndex, foundIndex - startIndex);
                    var beforePart = new FormattedTextPart { Text = beforeText, Type = part.Type, Href = part.Href };
                    AddFormattedRun(textBlock, beforePart);
                }
                
                // Add highlighted match
                var matchText = text.Substring(foundIndex, searchTerm.Length);
                var highlightRun = new Run(matchText);
                ApplyFormatting(highlightRun, part);
                
                // Apply highlight styling
                highlightRun.Background = new SolidColorBrush(Color.FromRgb(0xFF, 0xFF, 0x00)); // Yellow highlight
                highlightRun.Foreground = new SolidColorBrush(Color.FromRgb(0x00, 0x00, 0x00)); // Black text
                
                textBlock.Inlines.Add(highlightRun);
                
                startIndex = foundIndex + searchTerm.Length;
            }
            
            // Add remaining text after the last match
            if (startIndex < text.Length)
            {
                var remainingText = text.Substring(startIndex);
                var remainingPart = new FormattedTextPart { Text = remainingText, Type = part.Type, Href = part.Href };
                AddFormattedRun(textBlock, remainingPart);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void AddFormattedRun(TextBlock textBlock, FormattedTextPart part)
        {
            var run = new Run(part.Text);
            ApplyFormatting(run, part);
            
            // Handle special link types
            if (part.Type == "url" || part.Type == "text_link" || part.Type == "link")
            {
                var hyperlink = new Hyperlink(run);
                hyperlink.Click += (s, e) => OpenUrl(part.Href ?? part.Text);
                textBlock.Inlines.Add(hyperlink);
            }
            else
            {
                textBlock.Inlines.Add(run);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void ApplyFormatting(Run run, FormattedTextPart part)
        {
            switch (part.Type)
            {
                case "mention":
                case "hashtag":
                    run.Foreground = FindResource("AccentColor") as Brush;
                    run.FontWeight = FontWeights.Bold;
                    break;
                case "url":
                case "text_link":
                case "link":
                    run.Foreground = FindResource("AccentColor") as Brush;
                    run.TextDecorations = TextDecorations.Underline;
                    run.Cursor = Cursors.Hand;
                    break;
                case "bold":
                    run.FontWeight = FontWeights.Bold;
                    break;
                case "italic":
                    run.FontStyle = FontStyles.Italic;
                    break;
                case "code":
                    run.FontFamily = new FontFamily("Consolas");
                    run.Background = new SolidColorBrush(Color.FromRgb(0x1A, 0x1A, 0x1A));
                    run.Foreground = Brushes.White;
                    break;
                case "strikethrough":
                    run.TextDecorations = TextDecorations.Strikethrough;
                    break;
                case "underline":
                    run.TextDecorations = TextDecorations.Underline;
                    break;
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private bool TryLoadImage(string filePath, out BitmapImage imageSource)
        {
            imageSource = null;
            
            try
            {
                var resolvedPath = ResolveFilePath(filePath);
                if (resolvedPath == null || !File.Exists(resolvedPath))
                    return false;

                imageSource = new BitmapImage();
                imageSource.BeginInit();
                imageSource.UriSource = new Uri(resolvedPath, UriKind.Absolute);
                imageSource.DecodePixelWidth = 400; // Optimize memory usage
                imageSource.EndInit();
                imageSource.Freeze(); // Make it thread-safe

                return true;
            }
            catch (Exception ex)
            {
                _logger.Warning($"Failed to load image: {filePath} - {ex.Message}");
                return false;
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private string ResolveFilePath(string filePath)
        {
            if (string.IsNullOrEmpty(filePath))
                return null;

            // Try absolute path first
            if (Path.IsPathRooted(filePath) && File.Exists(filePath))
                return filePath;

            // Try relative to current directory
            if (File.Exists(filePath))
                return Path.GetFullPath(filePath);

            // Try relative to JSON file directory
            if (!string.IsNullOrEmpty(_jsonFileDirectory))
            {
                var jsonRelativePath = Path.Combine(_jsonFileDirectory, filePath);
                if (File.Exists(jsonRelativePath))
                    return Path.GetFullPath(jsonRelativePath);
            }

            return null;
        }

        private void OpenFile(string filePath)
        {
            try
            {
                var resolvedPath = ResolveFilePath(filePath);
                if (resolvedPath == null)
                {
                    MessageBox.Show($"File not found:\n{filePath}\n\nSearched in:\n- Current directory\n- JSON file directory: {_jsonFileDirectory ?? "Not set"}",
                        "File Not Found", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                Process.Start(new ProcessStartInfo
                {
                    FileName = resolvedPath,
                    UseShellExecute = true
                });

                _logger.Info($"Opened file: {resolvedPath}");
            }
            catch (Exception ex)
            {
                _logger.Error($"Failed to open file: {filePath}", ex);
                MessageBox.Show($"Failed to open file:\n{filePath}\n\nError: {ex.Message}",
                    "File Error", MessageBoxButton.OK, MessageBoxImage.Error);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void OpenUrl(string url)
        {
            try
            {
                if (!url.StartsWith("http://") && !url.StartsWith("https://"))
                    url = "https://" + url;

                Process.Start(new ProcessStartInfo
                {
                    FileName = url,
                    UseShellExecute = true
                });

                _logger.Info($"Opened URL: {url}");
            }
            catch (Exception ex)
            {
                _logger.Error($"Failed to open URL: {url}", ex);
                MessageBox.Show($"Failed to open URL:\n{url}\n\nError: {ex.Message}",
                    "URL Error", MessageBoxButton.OK, MessageBoxImage.Error);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private string GetMediaIcon(string mediaType)
        {
            return mediaType switch
            {
                "photo" => "🖼️",
                "video" => "🎬",
                "animation" => "🎞️",
                "sticker" => "😀",
                "voice" => "🎤",
                "video_message" => "📹",
                _ => "📎"
            };
        }

        private Brush GetMemberColor(string memberName)
        {
            if (!_memberColors.TryGetValue(memberName, out var color))
            {
                var colorIndex = Math.Abs(memberName.GetHashCode()) % _colorPalette.Length;
                color = _colorPalette[colorIndex];
                _memberColors[memberName] = color;
            }
            return color;
        }

        private Brush GetCachedResource(string resourceKey)
        {
            if (!_resourceCache.TryGetValue(resourceKey, out var brush))
            {
                brush = FindResource(resourceKey) as Brush;
                if (brush != null)
                {
                    _resourceCache[resourceKey] = brush;
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            return brush;
        }

        private void ShowLoadingUI(bool show, string status = "Loading...")
        {
            LoadingOverlay.Visibility = show ? Visibility.Visible : Visibility.Collapsed;
            if (show)
            {
                LoadingStatusText.Text = status;
                LoadingProgressBar.Value = 0;
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void UpdateProgress(double value, string status = "")
        {
            LoadingProgressBar.Value = value;
            if (!string.IsNullOrEmpty(status))
            {
                LoadingStatusText.Text = status;
                // Only show progress in StatusLabel if no chat is loaded yet
                if (string.IsNullOrEmpty(_chatName))
                {
                    StatusLabel.Text = $"{status} ({value:F0}%)";
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
        }

        // Search functionality
        private void SearchTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            _searchTimer.Stop();
            _searchTimer.Start();
            
            // Enable/disable Clear button based on whether there's text
            ClearSearchButton.IsEnabled = !string.IsNullOrWhiteSpace(SearchTextBox.Text);
        }

        private void SearchTextBox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                _searchTimer.Stop();
                PerformSearch();
            }
            else if (e.Key == Key.F3)
            {
                if (Keyboard.Modifiers == ModifierKeys.Shift)
                {
                    // Shift+F3 = Previous result
                    PrevSearchButton_Click(sender, e);
                }
                else
                {
                    // F3 = Next result
                    NextSearchButton_Click(sender, e);
                }
                e.Handled = true;
            }
            else if (e.Key == Key.Escape)
            {
                // Escape = Clear search
                ClearSearchButton_Click(sender, e);
                e.Handled = true;
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void SearchButton_Click(object sender, RoutedEventArgs e)
        {
            PerformSearch();
        }

        private void ClearSearchButton_Click(object sender, RoutedEventArgs e)
        {
            SearchTextBox.Text = "";
            ClearSearch();
        }

        private void PrevSearchButton_Click(object sender, RoutedEventArgs e)
        {
            if (_searchResults.Any() && _currentSearchIndex > 0)
            {
                _currentSearchIndex--;
                JumpToSearchResult(_currentSearchIndex);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void NextSearchButton_Click(object sender, RoutedEventArgs e)
        {
            if (_searchResults.Any() && _currentSearchIndex < _searchResults.Count - 1)
            {
                _currentSearchIndex++;
                JumpToSearchResult(_currentSearchIndex);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void PerformSearch()
        {
            var searchTerm = SearchTextBox.Text.Trim();
            
            if (string.IsNullOrEmpty(searchTerm))
            {
                ClearSearch();
                return;
            }

            if (_allMessages.Count == 0)
            {
                SearchResultsLabel.Text = "No messages loaded";
                return;
            }

            _currentSearchTerm = searchTerm;
            _searchResults = _messageParser.SearchMessages(_allMessages, searchTerm);

            if (_searchResults.Any())
            {
                _currentSearchIndex = 0;
                SearchResultsLabel.Text = $"Result 1 of {_searchResults.Count}";
                
                // Show navigation buttons
                PrevSearchButton.Visibility = Visibility.Visible;
                NextSearchButton.Visibility = Visibility.Visible;
                
                // Update button states
                UpdateSearchNavigationButtons();
                
                JumpToSearchResult(0);
                
                // Re-render messages with highlighting
                _ = Task.Run(async () => await Dispatcher.InvokeAsync(async () => await RerenderMessagesWithHighlighting()));
            }
            else
            {
                SearchResultsLabel.Text = "No results found";
                PrevSearchButton.Visibility = Visibility.Collapsed;
                NextSearchButton.Visibility = Visibility.Collapsed;
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void ClearSearch()
        {
            _searchResults.Clear();
            _currentSearchIndex = 0;
            _currentSearchTerm = "";
            SearchResultsLabel.Text = "";
            
            // Hide navigation buttons
            PrevSearchButton.Visibility = Visibility.Collapsed;
            NextSearchButton.Visibility = Visibility.Collapsed;
            
            // Re-render messages without highlighting
            _ = Task.Run(async () => await Dispatcher.InvokeAsync(async () => await RenderAllMessages()));
        }

        private void JumpToSearchResult(int resultIndex)
        {
            if (!_searchResults.Any() || resultIndex >= _searchResults.Count)
                return;

            var result = _searchResults[resultIndex];
            var messageIndex = _allMessages.IndexOf(result);

            if (messageIndex >= 0)
            {
                // Update search results label
                SearchResultsLabel.Text = $"Result {resultIndex + 1} of {_searchResults.Count}";
                
                // Update navigation button states
                UpdateSearchNavigationButtons();

                // If using virtual scrolling, scroll to the message
                if (_virtualScrollManager != null)
                {
                    _virtualScrollManager.ScrollToMessage(messageIndex);
                }
                else
                {
                    // For standard rendering, scroll to the specific message
                    ScrollToMessage(messageIndex);
                }

                _logger.Info($"Jumping to search result {resultIndex + 1}: message {messageIndex}");
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void ScrollToMessage(int messageIndex)
        {
            // Calculate approximate scroll position based on message index
            var totalMessages = _currentMessages.Count;
            if (totalMessages == 0) return;

            // Estimate scroll position (this is approximate)
            var scrollRatio = (double)messageIndex / totalMessages;
            var targetOffset = scrollRatio * ChatScrollViewer.ScrollableHeight;
            
            ChatScrollViewer.ScrollToVerticalOffset(targetOffset);
        }

        private void UpdateSearchNavigationButtons()
        {
            PrevSearchButton.IsEnabled = _currentSearchIndex > 0;
            NextSearchButton.IsEnabled = _currentSearchIndex < _searchResults.Count - 1;
        }

        private async Task RerenderMessagesWithHighlighting()
        {
            await RenderAllMessages();
        }

        private void AlternatingLayoutMenuItem_Click(object sender, RoutedEventArgs e)
        {
            _useAlternatingLayout = AlternatingLayoutMenuItem.IsChecked;
            _logger.Info($"Alternating layout: {(_useAlternatingLayout ? "enabled" : "disabled")}");
            
            // Re-render messages with new layout
            _ = Task.Run(async () => await Dispatcher.InvokeAsync(async () => await RenderAllMessages()));
        }

        private void AlternatingBackgroundMenuItem_Click(object sender, RoutedEventArgs e)
        {
            _useAlternatingBackgrounds = AlternatingBackgroundMenuItem.IsChecked;
            _logger.Info($"Alternating backgrounds: {(_useAlternatingBackgrounds ? "enabled" : "disabled")}");
            
            // Re-render messages with new background style
            _ = Task.Run(async () => await Dispatcher.InvokeAsync(async () => await RenderAllMessages()));
        }

        private void LightModeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            _isLightMode = LightModeMenuItem.IsChecked;
            _logger.Info($"Light mode: {(_isLightMode ? "enabled" : "disabled")}");
            
            // Switch theme
            SwitchTheme(_isLightMode);
            
            // Re-render messages with new theme
            _ = Task.Run(async () => await Dispatcher.InvokeAsync(async () => await RenderAllMessages()));
        }

        private void FastLoadingMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem != null)
            {
                _fastLoadingMode = menuItem.IsChecked;
                _logger.Info($"Fast loading mode {(_fastLoadingMode ? "enabled" : "disabled")}");
                
                // Update chunk size based on fast loading mode
                _progressiveLoadSize = _fastLoadingMode ? 1000 : 500;
                
                // Re-render messages if any are loaded to apply the new rendering mode
                if (_currentMessages.Any())
                {
                    _ = Task.Run(async () => await Dispatcher.InvokeAsync(async () => await RenderAllMessages()));
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
        }

        private void SwitchTheme(bool isLightMode)
        {
            _isLightMode = isLightMode;
            
            // Clear resource cache when switching themes
            ClearResourceCache();
            
            var resources = this.Resources;
            
            if (isLightMode)
            {
                // Restore Telegram light theme colors
                resources["PrimaryBackground"] = _lightBackground;
                resources["SecondaryBackground"] = _lightSecondaryBackground;
                resources["MessageInBackground"] = _lightMessageIncoming;
                resources["MessageOutBackground"] = _lightMessageOutgoing;
                resources["ServiceBackground"] = new SolidColorBrush(Color.FromRgb(0xE5, 0xF3, 0xDF));
                resources["ReplyBackground"] = new SolidColorBrush(Color.FromRgb(0xF0, 0xF8, 0xEB));
                resources["AccentColor"] = _lightAccent;
                resources["PrimaryText"] = _lightText;
                resources["SecondaryText"] = _lightSecondaryText;
                resources["ServiceText"] = new SolidColorBrush(Color.FromRgb(0x7E, 0x9E, 0x87));
                resources["ReplyText"] = new SolidColorBrush(Color.FromRgb(0x70, 0x8B, 0x75));
                resources["WelcomeText"] = new SolidColorBrush(Color.FromRgb(0x2C, 0x55, 0x30));
                resources["WelcomeSecondary"] = new SolidColorBrush(Color.FromRgb(0x70, 0x8B, 0x75));
                resources["MessageAltBackground1"] = new SolidColorBrush(Color.FromRgb(0xE9, 0xF5, 0xE3));
                resources["MessageAltBackground2"] = new SolidColorBrush(Color.FromRgb(0xD6, 0xE8, 0xCE));
                
                UpdateButtonStyles(true);
                UpdateMenuStyles(true);
            }
            else
            {
                // Switch to dark theme
                resources["PrimaryBackground"] = _darkBackground;
                resources["SecondaryBackground"] = _darkSecondaryBackground;
                resources["MessageInBackground"] = _darkMessageIncoming;
                resources["MessageOutBackground"] = _darkMessageOutgoing;
                resources["ServiceBackground"] = new SolidColorBrush(Color.FromRgb(0x2B, 0x2B, 0x2B));
                resources["ReplyBackground"] = new SolidColorBrush(Color.FromRgb(0x0E, 0x16, 0x21));
                resources["AccentColor"] = _darkAccent;
                resources["PrimaryText"] = _darkText;
                resources["SecondaryText"] = _darkSecondaryText;
                resources["ServiceText"] = new SolidColorBrush(Color.FromRgb(0xB0, 0xB0, 0xB0));
                resources["ReplyText"] = new SolidColorBrush(Color.FromRgb(0xFF, 0xFF, 0xFF));
                resources["WelcomeText"] = new SolidColorBrush(Color.FromRgb(0x2C, 0x55, 0x30));
                resources["WelcomeSecondary"] = new SolidColorBrush(Color.FromRgb(0x70, 0x8B, 0x75));
                resources["MessageAltBackground1"] = new SolidColorBrush(Color.FromRgb(0x17, 0x21, 0x2B));
                resources["MessageAltBackground2"] = new SolidColorBrush(Color.FromRgb(0x0E, 0x16, 0x21));
                
                // Update button and menu colors for dark theme
                UpdateButtonStyles(false);
                UpdateMenuStyles(false);
            }
            
            // Clear member colors cache to apply new theme colors
            _memberColors.Clear();
            
            // Force complete UI refresh
            this.InvalidateVisual();
            this.UpdateLayout();
            
            _logger.Info($"Theme switched to {(isLightMode ? "light" : "dark")} mode");
        }

        private void UpdateButtonStyles(bool isLightMode)
        {
            // Update all buttons in the UI
            UpdateButtonStyle(LoadButton, isLightMode);
            UpdateButtonStyle(SearchButton, isLightMode);
            UpdateButtonStyle(ClearSearchButton, isLightMode);
            UpdateButtonStyle(PrevSearchButton, isLightMode);
            UpdateButtonStyle(NextSearchButton, isLightMode);
            
            // Update buttons in welcome panel
            if (WelcomePanel.Child is StackPanel welcomeStack)
            {
                foreach (var child in welcomeStack.Children)
                {
                    if (child is Button welcomeButton)
                    {
                        UpdateButtonStyle(welcomeButton, isLightMode);
                        private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void UpdateButtonStyle(Button button, bool isLightMode)
        {
            if (button == null) return;
            
            if (isLightMode)
            {
                button.Background = FindResource("LightButtonBackground") as Brush ?? new SolidColorBrush(Color.FromRgb(0x2A, 0xAB, 0xEE));
                button.Foreground = new SolidColorBrush(Color.FromRgb(0xFF, 0xFF, 0xFF));
            }
            else
            {
                // Use dark theme
                button.Background = FindResource("DarkButtonBackground") as Brush ?? new SolidColorBrush(Color.FromRgb(0x2A, 0xAB, 0xEE));
                button.Foreground = new SolidColorBrush(Color.FromRgb(0xFF, 0xFF, 0xFF));
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void UpdateMenuStyles(bool isLightMode)
        {
            // Find and update the menu
            var menu = FindVisualChild<Menu>(this);
            if (menu != null)
            {
                if (isLightMode)
                {
                    menu.Background = FindResource("LightMenuBackground") as Brush ?? new SolidColorBrush(Color.FromRgb(0xDF, 0xEF, 0xD7));
                    menu.Foreground = new SolidColorBrush(Color.FromRgb(0x00, 0x00, 0x00));
                }
                else
                {
                    menu.Background = FindResource("DarkMenuBackground") as Brush ?? new SolidColorBrush(Color.FromRgb(0x0E, 0x16, 0x21));
                    menu.Foreground = new SolidColorBrush(Color.FromRgb(0xFF, 0xFF, 0xFF));
                }
                
                // Update all menu items
                UpdateMenuItemStyles(menu, isLightMode);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void UpdateMenuItemStyles(ItemsControl parent, bool isLightMode)
        {
            foreach (var item in parent.Items)
            {
                if (item is MenuItem menuItem)
                {
                    if (isLightMode)
                    {
                        menuItem.Background = FindResource("LightMenuBackground") as Brush ?? new SolidColorBrush(Color.FromRgb(0xDF, 0xEF, 0xD7));
                        menuItem.Foreground = new SolidColorBrush(Color.FromRgb(0x00, 0x00, 0x00));
                        
                        // Create light theme style for menu items
                        var style = new Style(typeof(MenuItem));
                        style.Setters.Add(new Setter(MenuItem.BackgroundProperty, menuItem.Background));
                        style.Setters.Add(new Setter(MenuItem.ForegroundProperty, menuItem.Foreground));
                        
                        var hoverTrigger = new Trigger { Property = MenuItem.IsHighlightedProperty, Value = true };
                        hoverTrigger.Setters.Add(new Setter(MenuItem.BackgroundProperty, FindResource("LightMenuHover") as Brush ?? new SolidColorBrush(Color.FromRgb(0xD6, 0xE8, 0xCE))));
                        hoverTrigger.Setters.Add(new Setter(MenuItem.ForegroundProperty, new SolidColorBrush(Color.FromRgb(0x00, 0x00, 0x00))));
                        style.Triggers.Add(hoverTrigger);
                        
                        menuItem.Style = style;
                    }
                    else
                    {
                        menuItem.Background = FindResource("DarkMenuBackground") as Brush ?? new SolidColorBrush(Color.FromRgb(0x0E, 0x16, 0x21));
                        menuItem.Foreground = new SolidColorBrush(Color.FromRgb(0xFF, 0xFF, 0xFF));
                        
                        // Create dark theme style for menu items
                        var style = new Style(typeof(MenuItem));
                        style.Setters.Add(new Setter(MenuItem.BackgroundProperty, menuItem.Background));
                        style.Setters.Add(new Setter(MenuItem.ForegroundProperty, menuItem.Foreground));
                        
                        var hoverTrigger = new Trigger { Property = MenuItem.IsHighlightedProperty, Value = true };
                        hoverTrigger.Setters.Add(new Setter(MenuItem.BackgroundProperty, FindResource("DarkMenuHover") as Brush ?? new SolidColorBrush(Color.FromRgb(0x17, 0x21, 0x2B))));
                        hoverTrigger.Setters.Add(new Setter(MenuItem.ForegroundProperty, new SolidColorBrush(Color.FromRgb(0xFF, 0xFF, 0xFF))));
                        style.Triggers.Add(hoverTrigger);
                        
                        menuItem.Style = style;
                    }
                    
                    // Recursively update sub-menu items
                    UpdateMenuItemStyles(menuItem, isLightMode);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
        }

        // Helper method to find visual children
        private T FindVisualChild<T>(DependencyObject parent) where T : DependencyObject
        {
            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                if (child is T result)
                    return result;
                
                var childOfChild = FindVisualChild<T>(child);
                if (childOfChild != null)
                    return childOfChild;
            }
            return null;
        }

        private void OpenLogMenuItem_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                var logDirectory = _logger.GetLogDirectory();
                if (Directory.Exists(logDirectory))
                {
                    System.Diagnostics.Process.Start("explorer.exe", logDirectory);
                    _logger.Info($"Opened log directory: {logDirectory}");
                }
                else
                {
                    MessageBox.Show($"Log directory not found: {logDirectory}", "Directory Not Found", 
                        MessageBoxButton.OK, MessageBoxImage.Warning);
                    private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
            catch (Exception ex)
            {
                _logger.Error("Failed to open log directory", ex);
                MessageBox.Show($"Failed to open log directory: {ex.Message}", "Error", 
                    MessageBoxButton.OK, MessageBoxImage.Error);
                private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}

        private void AboutMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var aboutWindow = new AboutWindow
            {
                Owner = this
            };
            aboutWindow.ShowDialog();
        }

        // Public methods for infinite scroll control
        public void SetInfiniteScrollThreshold(double threshold)
        {
            _scrollThreshold = Math.Clamp(threshold, 0.5, 0.95);
            _logger.Info($"Infinite scroll threshold set to {_scrollThreshold:P0}");
        }

        public void SetScrollCooldown(int milliseconds)
        {
            // Dynamically update cooldown (though timer interval is fixed)
            _logger.Info($"Scroll cooldown set to {milliseconds}ms");
        }

        public bool IsInfiniteScrollActive => _infiniteScrollEnabled && !_isLoadingMore;

        public double GetCurrentScrollPosition()
        {
            if (ChatScrollViewer?.ScrollableHeight > 0)
            {
                return ChatScrollViewer.VerticalOffset / ChatScrollViewer.ScrollableHeight;
            }
            return 0;
        }

        // Optimized message creation with simplified UI elements for better performance
        private Border CreateSimplifiedMessageBubble(TelegramMessage message, bool useAlternateUserBackground)
        {
            var bubbleBackground = _useAlternatingBackgrounds
                ? (useAlternateUserBackground ? GetCachedResource("MessageAltBackground2") : GetCachedResource("MessageAltBackground1"))
                : (message.IsOutgoing ? GetCachedResource("MessageOutBackground") : GetCachedResource("MessageInBackground"));

            var bubble = new Border
            {
                Background = bubbleBackground,
                CornerRadius = new CornerRadius(12),
                Padding = new Thickness(12, 8, 12, 8),
                MaxWidth = 600
            };

            var contentPanel = new StackPanel();

            // Simplified text content - only basic text, defer complex formatting
            if (!string.IsNullOrEmpty(message.PlainText))
            {
                var textBlock = new TextBlock
                {
                    Text = message.PlainText,
                    FontFamily = new FontFamily("Segoe UI"),
                    FontSize = 13,
                    Foreground = GetCachedResource("PrimaryText"),
                    TextWrapping = TextWrapping.Wrap,
                    LineHeight = 18
                };
                contentPanel.Children.Add(textBlock);
            }

            // Simplified timestamp
            var timeLabel = new TextBlock
            {
                Text = message.ParsedDate.ToString("HH:mm"),
                FontSize = 10,
                Foreground = GetCachedResource("SecondaryText"),
                HorizontalAlignment = HorizontalAlignment.Right,
                Margin = new Thickness(0, 4, 0, 0)
            };

            contentPanel.Children.Add(timeLabel);
            bubble.Child = contentPanel;

            return bubble;
        }

        // Clear resource cache when switching themes to prevent memory leaks
        private void ClearResourceCache()
        {
            _resourceCache.Clear();
            private void ChunkSizeMenuItem_Click(object sender, RoutedEventArgs e)
        {
            var menuItem = sender as MenuItem;
            if (menuItem == null) return;

            // Get the chunk size from the Tag
            if (int.TryParse(menuItem.Tag?.ToString(), out int chunkSize))
            {
                _progressiveLoadSize = chunkSize;
                _logger.Info($"Chunk size changed to {chunkSize:N0} messages");

                // Update all chunk size menu items
                ChunkSize500MenuItem.IsChecked = chunkSize == 500;
                ChunkSize1000MenuItem.IsChecked = chunkSize == 1000;
                ChunkSize10000MenuItem.IsChecked = chunkSize == 10000;
                ChunkSize50000MenuItem.IsChecked = chunkSize == 50000;

                // Update status to show current settings
                UpdateChunkSizeStatus();
            }
        }

        private void UpdateChunkSizeStatus()
        {
            var statusSuffix = "";
            if (_progressiveLoadSize >= 50000)
                statusSuffix = " (Ultra Fast Mode)";
            else if (_progressiveLoadSize >= 10000)
                statusSuffix = " (Fast Mode)";
            else if (_progressiveLoadSize >= 1000)
                statusSuffix = " (Normal+ Mode)";

            if (!string.IsNullOrEmpty(_chatName))
            {
                StatusLabel.Text = $"{_chatName} • {_currentMessages.Count:N0}/{_allMessages.Count:N0} messages • Chunk: {_progressiveLoadSize:N0}{statusSuffix}";
            }
        } 
    }
}
}  
 
